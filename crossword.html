<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Crossword â€“ NSTW 2025 (Touch TV + iPhone)</title>
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#3446b8">
<style>
  :root{
    --vh: 1vh;
    --gap: 2px;
    --cell-min: 62px;
    --focus-outline: 4px;
    --board-size: 680px;
    --kb-row: 64px;
    --gutter: 12px;
    --drawerW: 0px;
    --ink: #0f172a;
    --accent: #5b8cff;
    --ok: #22c55e;
    --bad: #ef4444;
    --ink-soft: #b9c2d0;
  }

  html, body { height: 100%; overflow: hidden; }
  * { box-sizing: border-box; }

  body{
    margin:0;
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    color:#f8fafc;
    -webkit-tap-highlight-color: transparent;
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    padding-top: calc(env(safe-area-inset-top) * 1);
    padding-bottom: calc(env(safe-area-inset-bottom) * 1);

    background:
      radial-gradient(1100px 700px at 80% 20%, rgba(0,0,0,.25), transparent 60%),
      linear-gradient(rgba(0, 0, 0, 0.20), rgba(0,0,0,.20)),
      url("assets/Background-33.jpg");
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    background-attachment: fixed;
  }

  .app {
    position: relative;
    height: calc(var(--vh) * 100);
    max-width: 100vw;
    margin: 0 auto;
    padding: var(--gutter);
    user-select: none; outline: none;
    display: flex; flex-direction: column; gap: 10px;
  }

  .topbar { display:flex; align-items:center; justify-content:space-between; gap:10px; }
  .brand { display:flex; align-items:center; gap:10px; flex:1 1 auto; min-width:0; }
  .brand h1 { font-size: clamp(18px, 2.6vw, 34px); margin: 0; font-weight: 900; letter-spacing:.2px; }
  .brand small { opacity:.85; font-weight:600; color:#b9c2d0; white-space:nowrap; }

  .buttons { display:flex; gap:8px; flex-wrap:nowrap; overflow:auto; padding-bottom:2px; }
  .buttons::-webkit-scrollbar { display:none; }
  .btn{
    font: inherit; padding: 8px 12px; border-radius: 12px; border:1px solid rgba(255,255,255,.28);
    background: rgba(255,255,255,.14); color:#fff; cursor:pointer; touch-action:manipulation;
    backdrop-filter: blur(8px) saturate(120%); -webkit-backdrop-filter: blur(8px) saturate(120%);
    box-shadow: 0 6px 18px rgba(0,0,0,.22), inset 0 0 0 1px rgba(255,255,255,.08);
    transition: transform .08s ease, background .15s ease;
    white-space: nowrap;
  }
  .btn:active{ transform: translateY(1px) scale(.99); }
  .btn.primary{ background: rgba(255,255,255,.20); border-color: rgba(255,255,255,.36); }
  .btn.badge{ position:relative; padding-left:11px; padding-right:11px; }
  .btn .badge-dot{ width:8px; height:8px; border-radius:50%; background:#22d3ee; display:inline-block; margin-left:8px; }

  .progress { height:6px; width:100%; background:rgba(255,255,255,.18); border-radius:999px; overflow:hidden; }
  .progress > i{ display:block; height:100%; width:0%; background:linear-gradient(90deg,#22d3ee,#38bdf8,#60a5fa); transition:width .25s ease; }

  .stage { display:grid; place-items:center; gap:12px; height: calc(calc(var(--vh) * 100) - 120px); min-height:420px; padding-right: var(--drawerW); transition: padding-right .18s ease; }
  .board-wrap{ display:flex; flex-direction:column; align-items:center; gap:10px; }

  .board{
    width: var(--board-size); height: var(--board-size); background: rgba(255,255,255,.06);
    display:grid; gap:var(--gap); touch-action: manipulation; border-radius:16px;
    box-shadow: inset 0 2px 10px rgba(0,0,0,.25), 0 10px 24px rgba(0,0,0,.35); padding:8px;
  }
  .grid{ width:100%; height:100%; display:grid; }

  .kb-wrap{ width: var(--board-size); }
  .keyboard{ display:grid; gap:6px; }
  .kb-row{ display:grid; grid-auto-rows: var(--kb-row); gap:6px; }
  .kb-row.numbers{ grid-template-columns: repeat(10, 1fr); }
  .kb-row.row1   { grid-template-columns: repeat(13, 1fr); }
  .kb-row.row2   { grid-template-columns: repeat(13, 1fr); }
  .kb-row.actions{ grid-template-columns: 1.4fr 2.2fr 1.6fr; }

  .keyboard button{
    border:1px solid rgba(255,255,255,.28); border-radius:12px; background:rgba(255,255,255,.14);
    color:#fff; font-size:clamp(16px, 2.2vw, 28px); font-weight:800; letter-spacing:.5px;
    box-shadow: 0 6px 18px rgba(0,0,0,.22), inset 0 0 0 1px rgba(255,255,255,.08);
    backdrop-filter: blur(8px) saturate(130%); -webkit-backdrop-filter: blur(8px) saturate(130%);
    transition: transform .08s ease, background .12s ease;
  }
  .keyboard button:active{ transform: translateY(1px) scale(.99); }

  .hint{ text-align:center; font-size:13px; color:#e2e8f0; opacity:.95; text-shadow:0 2px 10px rgba(0,0,0,.55); }

  .cell{
    position:relative; background:rgba(255,255,255,.96); display:grid; place-items:center; font-weight:900;
    min-width: var(--cell-min); min-height: var(--cell-min);
    font-size: clamp(18px, 4.2vw, 42px);
    border-radius:10px; box-shadow:0 1px 0 rgba(0,0,0,.08); color:#0b1220;
  }
  .cell.block{ background:#0b1120; border-radius:12px; box-shadow: inset 0 0 0 1px rgba(255,255,255,.06); }
  .cell.active:not(.block){ background:linear-gradient(#ffffff,#f8fbff); box-shadow:0 0 0 3px rgba(91,140,255,.18) inset; }
  .cell.focus:not(.block){ outline: var(--focus-outline) solid var(--accent); outline-offset:-4px; z-index:2; }
  .cell.ok{ box-shadow: inset 0 0 0 4px var(--ok); }
  .cell.bad{ box-shadow: inset 0 0 0 4px var(--bad); }

  .num{ position:absolute; top:4px; left:6px; opacity:.85; font-weight:800; font-size:clamp(10px,3vw,14px); line-height:1; color:#64748b; }
  .letter{ letter-spacing:.5px; }

  .clues-drawer{
    position: absolute; right: var(--gutter); top: calc(58px + var(--gutter)); bottom: var(--gutter);
    width: 360px; background: #0b1220; border: 1px solid #1f2937; border-radius: 18px; padding: 12px; overflow: hidden;
    backdrop-filter: none !important; -webkit-backdrop-filter: none !important; box-shadow: 0 14px 34px rgba(0,0,0,.45);
    transition: transform .18s ease, opacity .18s ease; z-index: 30; pointer-events: auto;
  }
  .clues-drawer.collapsed{ transform: translateX(390px); opacity:0; pointer-events:none; }
  .clues-head{ display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
  .clues-head h2{ margin:0; font-size:18px; }
  .clues-body{ position:absolute; inset:56px 10px 10px 10px; overflow:auto; }
  .clue{ font-size:16px; margin:4px 0; padding:8px 10px; border-radius:10px; line-height:1.35; background:#0f172a; border:1px solid transparent; color:#e5eaf3; }
  .clue small{ opacity:.75; }
  .clue.active{ background:#111b2e; border-color:#3756a8; }

  .toast{
    position: fixed; left: 50%; bottom: calc(16px + env(safe-area-inset-bottom));
    transform: translateX(-50%); background: #0b1220; color:#fff; padding: 12px 18px; border-radius: 12px; font-weight: 700;
    box-shadow: 0 14px 30px rgba(0,0,0,.45);
  }

  @media (max-width: 430px){
    :root{ --cell-min: 44px; }
    .btn { padding: 7px 10px; }
    .kb-row { grid-auto-rows: minmax(46px, var(--kb-row)); }
    .clues-drawer{ width: 320px; }
  }
  @media (max-width: 414px){
    :root{ --cell-min: 42px; }
    .brand h1 { font-size: 20px; }
    .kb-row { grid-auto-rows: minmax(44px, var(--kb-row)); }
    .clues-drawer{ width: 300px; }
  }
  @media (max-width: 390px){
    :root{ --cell-min: 40px; }
    .btn { padding: 6px 9px; }
    .keyboard button { font-size: 16px; }
    .kb-row { grid-auto-rows: minmax(42px, var(--kb-row)); }
  }

  @media (max-height: 500px) and (orientation: landscape){
    :root{ --kb-row: 44px; }
    .keyboard button { font-size: 15px; }
    .brand small { display:none; }
  }
</style>
</head>
<body>

<div class="app" tabindex="0" id="app">

  <div class="topbar">
    <div class="brand">
      <h1>Crossword</h1>
      <small>NSTW 2025</small>
    </div>
    <div class="buttons">
      <button class="btn badge" id="btnClues">Clues <span class="badge-dot"></span></button>
      <button class="btn" id="btnToggle">Across</button>
      <button class="btn" id="btnClear">Clear</button>
      <button class="btn" id="btnReset">Reset</button>
      <button class="btn" id="btnBack">Back to Landing</button>
      <button class="btn primary" id="btnFS">Fullscreen</button>
    </div>
  </div>

  <div class="progress"><i id="progressFill"></i></div>

  <div class="stage">
    <div class="board-wrap">
      <div class="board">
        <div class="grid" id="board" aria-label="Crossword board"></div>
      </div>

      <div class="kb-wrap">
        <div class="keyboard" id="keyboard">
          <div class="kb-row numbers" id="kbNumbers"></div>
          <div class="kb-row row1"    id="kbRow1"></div>
          <div class="kb-row row2"    id="kbRow2"></div>
          <div class="kb-row actions" id="kbActions"></div>
        </div>
      </div>

      <div class="hint">Tip: Tap a cell to select; tap again to toggle Across/Down. Arrow keys & D-pads work too.</div>
    </div>
  </div>

  <aside id="drawer" class="clues-drawer">
    <div class="clues-head">
      <h2>Active clue</h2>
      <button class="btn" id="btnCloseDrawer" style="padding:6px 10px;">Hide</button>
    </div>
    <div class="clues-body">
      <div id="activeClue" class="clue" style="font-weight:800;border:1px dashed rgba(255,255,255,.18);"></div>
      <h3 style="margin:12px 6px 6px;">Across</h3>
      <div id="acrossClues"></div>
      <h3 style="margin:12px 6px 6px;">Down</h3>
      <div id="downClues"></div>
    </div>
  </aside>
</div>

<script>
(() => {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('serviceworker.js');
  }

  function setVh() {
    const base = window.innerHeight;
    document.documentElement.style.setProperty('--vh', `${base * 0.01}px`);
  }
  setVh();
  window.addEventListener('resize', setVh);
  window.addEventListener('orientationchange', setVh);

  const ROWS = 7, COLS = 7;
  const TOTAL_CLUES = 10;
  const TARGET_ACROSS = 5;
  const TARGET_DOWN   = TOTAL_CLUES - TARGET_ACROSS;
  const LANDING_URL   = 'index.html';

  const PUZZLE_KEY   = 'crossword-nstw2025-puzzle-v8';
  const PROGRESS_KEY = 'crossword-nstw2025-progress-v1';

  const WORD_BANK = [
    {answer:'AI', clue:'Two-letter tech term'},
    {answer:'AR', clue:'Overlay on reality'},
    {answer:'VR', clue:'Immersive display tech'},
    {answer:'IO', clue:'In/Out pair'},
    {answer:'OS', clue:'Phone or PC core'},
    {answer:'APP', clue:'Phone program'},
    {answer:'BOT', clue:'Automated helper'},
    {answer:'LAB', clue:'Research workplace'},
    {answer:'CPU', clue:'Computer brain (abbr.)'},
    {answer:'GPU', clue:'Graphics processor (abbr.)'},
    {answer:'RAM', clue:'Short-term memory (abbr.)'},
    {answer:'ION', clue:'Charged atom'},
    {answer:'SUN', clue:'Our star'},
    {answer:'NET', clue:'Interconnected mesh'},
    {answer:'CAT', clue:'Friendly feline'},
    {answer:'DNA', clue:'Genetic blueprint'},
    {answer:'DATA', clue:'Numbers and facts'},
    {answer:'CODE', clue:'What developers write'},
    {answer:'BYTE', clue:'Eight bits'},
    {answer:'STAR', clue:'Luminous sphere'},
    {answer:'WAVE', clue:'Oscillation'},
    {answer:'LASER', clue:'Amplified light beam'},
    {answer:'ROBOT', clue:'Programmable machine'},
    {answer:'QUARK', clue:'Tiny particle'},
    {answer:'PYTHON', clue:'Popular language'},
    {answer:'SCRIPT', clue:'Program text'},
    {answer:'PLANET', clue:'Orbits a star'},
    {answer:'NETWORK', clue:'Interconnected system'},
    {answer:'SCIENCE', clue:'Systematic study of nature'},
    {answer:'ANALYZE', clue:'Examine in detail'},
    {answer:'ROBOTIC', clue:'Machine-like'}
  ];

  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
  function byLen(){ const g={}; for(const w of WORD_BANK){ const L=w.answer.length; (g[L]||(g[L]=[])).push({...w}); } for(const k in g) shuffle(g[k]); return g; }

  function buildTenSlotPuzzle(){
    const L = Array.from({length:ROWS},()=>Array(COLS).fill(null));
    const S = Array.from({length:ROWS},()=>Array(COLS).fill(null));
    const buckets = byLen();
    const used = new Set();

    const acrossRows = [0,2,4,6,3];
    const downCols   = [0,2,4,6,1];

    const across=[], down=[];
    // place across
    for(const r of acrossRows){
      const candidates = Object.values(buckets).flat().filter(w=>!used.has(w.answer) && w.answer.length<=COLS);
      let placed=false;
      for(const w of shuffle(candidates)){
        const len=w.answer.length, c0=Math.max(0,Math.floor((COLS-len)/2));
        let ok=true;
        for(let i=0;i<len;i++){ const ch=S[r][c0+i]; if(ch && ch!==w.answer[i]){ok=false;break;} }
        if(!ok) continue;
        for(let i=0;i<len;i++){ L[r][c0+i]=""; S[r][c0+i]=w.answer[i]; }
        used.add(w.answer);
        across.push({dir:'across',r,c:c0,len,answer:w.answer,clue:w.clue});
        placed=true; break;
      }
      if(!placed) return null;
    }
    // place down
    for(const c of downCols){
      const candidates = Object.values(buckets).flat().filter(w=>!used.has(w.answer) && w.answer.length<=ROWS);
      let placed=false;
      for(const w of shuffle(candidates)){
        const len=w.answer.length, r0=Math.max(0,Math.floor((ROWS-len)/2));
        let ok=true;
        for(let i=0;i<len;i++){ const ch=S[r0+i][c]; if(ch && ch!==w.answer[i]){ok=false;break;} }
        if(!ok) continue;
        for(let i=0;i<len;i++){ L[r0+i][c]=""; S[r0+i][c]=w.answer[i]; }
        used.add(w.answer);
        down.push({dir:'down',r:r0,c,len,answer:w.answer,clue:w.clue});
        placed=true; break;
      }
      if(!placed) return null;
    }
    if(across.length!==5 || down.length!==5) return null;

    // numbering
    const numMap=Array.from({length:ROWS},()=>Array(COLS).fill(''));
    let num=0;
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(L[r][c]===null) continue;
        const startsAcross=(c===0||L[r][c-1]===null)&&(c+1<COLS&&L[r][c+1]!==null);
        const startsDown=(r===0||L[r-1]?.[c]===null)&&(r+1<ROWS&&L[r+1]?.[c]!==null);
        if(startsAcross||startsDown) numMap[r][c]=String(++num);
      }
    }
    const attachNums = (list, key)=>list.forEach(s=>{ s.num = Number(numMap[s.r][s.c]||0); });
    attachNums(across); attachNums(down);

    const CLUES_ACROSS={}, CLUES_DOWN={};
    across.forEach(s=>CLUES_ACROSS[s.num]={clue:s.clue,answer:s.answer,r:s.r,c:s.c});
    down.forEach(s=>CLUES_DOWN[s.num]={clue:s.clue,answer:s.answer,r:s.r,c:s.c});

    const mapAcross=Array.from({length:ROWS},()=>Array(COLS).fill(null));
    const mapDown=Array.from({length:ROWS},()=>Array(COLS).fill(null));
    across.forEach(s=>{for(let i=0;i<s.len;i++) mapAcross[s.r][s.c+i]={...s}});
    down.forEach(s=>{for(let i=0;i<s.len;i++) mapDown[s.r+i][s.c]={...s}});

    return {LAYOUT:L,SOLUTION:S,numMap,pickedAcross:across,pickedDown:down,mapAcross,mapDown,CLUES_ACROSS,CLUES_DOWN};
  }

  function buildRandomPuzzle(){
    for(let tries=0; tries<12; tries++){
      const puz = buildTenSlotPuzzle();
      if (puz) return puz;
    }
    // minimal fallback to avoid hangs
    const L=Array.from({length:ROWS},()=>Array(COLS).fill(null));
    const S=Array.from({length:ROWS},()=>Array(COLS).fill(null));
    const numMap=Array.from({length:ROWS},()=>Array(COLS).fill(''));
    const chosen = shuffle(WORD_BANK.filter(w=>w.answer.length<=7)).slice(0,10);
    let num=0; const across=[], down=[];
    for(let i=0;i<5;i++){
      const w=chosen[i], len=w.answer.length, r=i, c=Math.max(0,Math.floor((COLS-len)/2));
      numMap[r][c]=String(++num);
      for(let j=0;j<len;j++){ L[r][c+j]=''; S[r][c+j]=w.answer[j]; }
      across.push({dir:'across',r,c,len,num,answer:w.answer,clue:w.clue});
    }
    const cols=[6,5,4,3,2];
    for(let i=5;i<10;i++){
      const w=chosen[i], len=w.answer.length, c=cols[i-5], r=Math.max(0,Math.floor((ROWS-len)/2));
      numMap[r][c]=String(++num);
      for(let j=0;j<len;j++){ L[r+j][c]=''; S[r+j][c]=w.answer[j]; }
      down.push({dir:'down',r,c,len,num,answer:w.answer,clue:w.clue});
    }
    const CLUES_ACROSS={}, CLUES_DOWN={};
    across.forEach(s=>CLUES_ACROSS[s.num]={clue:s.clue,answer:s.answer,r:s.r,c:s.c});
    down.forEach(s=>CLUES_DOWN[s.num]={clue:s.clue,answer:s.answer,r:s.r,c:s.c});
    const mapAcross=Array.from({length:ROWS},()=>Array(COLS).fill(null));
    const mapDown=Array.from({length:ROWS},()=>Array(COLS).fill(null));
    across.forEach(s=>{for(let i=0;i<s.len;i++) mapAcross[s.r][s.c+i]={...s}});
    down.forEach(s=>{for(let i=0;i<s.len;i++) mapDown[s.r+i][s.c]={...s}});
    return {LAYOUT:L,SOLUTION:S,numMap,pickedAcross:across,pickedDown:down,mapAcross,mapDown,CLUES_ACROSS,CLUES_DOWN};
  }

  function savePuzzle(p){ localStorage.setItem(PUZZLE_KEY, JSON.stringify(p)); }
  function loadPuzzle(){ try{ return JSON.parse(localStorage.getItem(PUZZLE_KEY)) } catch { return null; } }
  function clearProgress(){ localStorage.removeItem(PROGRESS_KEY); }
  function saveProgress(o){ localStorage.setItem(PROGRESS_KEY, JSON.stringify(o)); }
  function loadProgress(){ try{ return JSON.parse(localStorage.getItem(PROGRESS_KEY)) } catch { return null; } }

  let PUZZLE = loadPuzzle();
  if(!PUZZLE){ PUZZLE = buildRandomPuzzle(); savePuzzle(PUZZLE); }

  let { LAYOUT, SOLUTION, CLUES_ACROSS, CLUES_DOWN, pickedAcross: PICKED_ACROSS, pickedDown: PICKED_DOWN } = PUZZLE;

  let grid = [];
  let focus = { r:0, c:0 };
  let dir = 'across';

  const app = document.getElementById('app');
  const board = document.getElementById('board');
  const progressFill = document.getElementById('progressFill');
  const activeClueEl = document.getElementById('activeClue');
  const acrossCluesEl = document.getElementById('acrossClues');
  const downCluesEl = document.getElementById('downClues');
  const drawer = document.getElementById('drawer');

  const kbNumbers = document.getElementById('kbNumbers');
  const kbRow1    = document.getElementById('kbRow1');
  const kbRow2    = document.getElementById('kbRow2');
  const kbActions = document.getElementById('kbActions');

  '1234567890'.split('').forEach(k => kbNumbers.appendChild(makeKey(k, () => typeKey(k))));
  'ABCDEFGHIJKLM'.split('').forEach(k => kbRow1.appendChild(makeKey(k, () => typeKey(k))));
  'NOPQRSTUVWXYZ'.split('').forEach(k => kbRow2.appendChild(makeKey(k, () => typeKey(k))));
  kbActions.appendChild(makeKey('âŒ«', backspace));
  kbActions.appendChild(makeKey('ACROSS/DOWN', toggleDir));
  kbActions.appendChild(makeKey('CLEAR', clearWord));

  function makeKey(label, handler){
    const b = document.createElement('button');
    b.textContent = label;
    b.addEventListener('pointerdown', e => { e.preventDefault(); handler(); if (navigator.vibrate) navigator.vibrate(8); }, {passive:false});
    return b;
  }

  document.getElementById('btnToggle').addEventListener('click', () => { toggleDir(); app.focus(); });
  document.getElementById('btnClear').addEventListener('click', clearWord);
  document.getElementById('btnReset').addEventListener('click', resetPuzzleKeepWords);
  document.getElementById('btnFS').addEventListener('click', () => { document.documentElement.requestFullscreen?.(); });
  document.getElementById('btnBack').addEventListener('click', () => { window.location.href = LANDING_URL; });

  document.getElementById('btnClues').addEventListener('click', () => { drawer.classList.toggle('collapsed'); computeLayout(); });
  document.getElementById('btnCloseDrawer').addEventListener('click', () => { drawer.classList.add('collapsed'); computeLayout(); });

  const onKey = (e) => {
    const tag = (e.target.tagName || '').toLowerCase();
    if (tag === 'input' || tag === 'textarea' || tag === 'select' || e.isComposing) return;
    const k = e.key.toUpperCase();
    if (e.repeat) { e.preventDefault(); return; }
    if (/^[A-Z0-9]$/.test(k)) { e.preventDefault(); e.stopPropagation(); typeKey(k); return; }
    if (e.key === 'Backspace') { e.preventDefault(); e.stopPropagation(); backspace(); return; }
    if (e.key === 'ArrowRight') { e.preventDefault(); dir='across'; moveNext(); return; }
    if (e.key === 'ArrowLeft')  { e.preventDefault(); dir='across'; movePrev(); return; }
    if (e.key === 'ArrowDown')  { e.preventDefault(); dir='down';   moveNext(); return; }
    if (e.key === 'ArrowUp')    { e.preventDefault(); dir='down';   movePrev(); return; }
  };
  if (!window.__CROSSWORD_KEYS_BOUND__){
    window.addEventListener('keydown', onKey, {capture:true});
    window.__CROSSWORD_KEYS_BOUND__ = true;
  }
  document.addEventListener('pointerdown', (ev) => {
    const tag = (ev.target.tagName || '').toLowerCase();
    if (tag !== 'input' && tag !== 'textarea' && tag !== 'select') { app?.focus?.(); }
  }, { passive:true });

  function buildGrid(){
    let n=0;
    grid = LAYOUT.map((row,r)=>row.map((v,c)=>{
      const block = v===null;
      const startsAcross = !block && (c===0 || LAYOUT[r][c-1]===null);
      const startsDown   = !block && (r===0 || LAYOUT[r-1]?.[c]===null);
      const num = (startsAcross || startsDown) ? ++n : '';
      return { r,c,block,letter:'',num };
    }));
  }

  function renderBoard(){
    board.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
    board.innerHTML = '';
    grid.flat().forEach(cell=>{
      const el = document.createElement('div');
      el.className = `cell${cell.block?' block':''}`;
      el.dataset.r = cell.r; el.dataset.c = cell.c;
      el.dataset.stateacross = '';
      el.dataset.statedown = '';

      if (cell.num){ const s=document.createElement('small'); s.className='num'; s.textContent=cell.num; el.appendChild(s); }
      const span=document.createElement('span'); span.className='letter'; span.textContent=cell.letter||''; el.appendChild(span);
      el.addEventListener('pointerdown', e=>{ e.preventDefault(); onCellTap(cell); }, {passive:false});
      board.appendChild(el);
    });
    updateHighlights(); renderClues(); updateActiveClue();
    validateAllWords();
    computeLayout(); updateProgress();
  }

  function getCell(r,c){ return grid[r]?.[c]; }
  function cellEl(r,c){ return board.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); }

  function onCellTap(cell){
    if (cell.block) return;
    const same = (cell.r===focus.r && cell.c===focus.c);
    if (same) dir = (dir==='across') ? 'down' : 'across';
    focus = { r:cell.r, c:cell.c };
    if (wordCellsAt(focus.r,focus.c,dir).length===1){ dir = (dir==='across')?'down':'across'; }
    updateHighlights(); updateActiveClue();
    validateBothDirectionsAt(focus.r, focus.c);
    save();
  }

  function wordCellsAt(r,c,d){
    const cells=[];
    if (d==='across'){
      let cc=c; while (cc>0 && !getCell(r,cc-1).block) cc--;
      while (cc<COLS && !getCell(r,cc).block){ cells.push(getCell(r,cc)); cc++; }
    }else{
      let rr=r; while (rr>0 && !getCell(rr-1,c).block) rr--;
      while (rr<ROWS && !getCell(rr,c).block){ cells.push(getCell(rr,c)); rr++; }
    }
    return cells;
  }
  function currentWordCells(){ return wordCellsAt(focus.r,focus.c,dir); }

  function updateHighlights(){
    board.querySelectorAll('.cell').forEach(el=>el.classList.remove('active','focus'));
    currentWordCells().forEach(c=>{ const el=cellEl(c.r,c.c); if (el) el.classList.add('active'); });
    const f = cellEl(focus.r,focus.c);
    if (f && !getCell(focus.r,focus.c).block) f.classList.add('focus');
    document.getElementById('btnToggle').textContent = (dir==='across')?'Across':'Down';
  }

  function applyMergedState(el){
    const a = el.dataset.stateacross || '';
    const d = el.dataset.statedown || '';
    el.classList.remove('ok','bad');
    if (a === 'bad' || d === 'bad') el.classList.add('bad');
    else if (a === 'ok' || d === 'ok') el.classList.add('ok');
  }

  function setWordStateForCell(r,c,dir,state){
    const el = cellEl(r,c);
    if (!el) return;
    if (dir === 'across') el.dataset.stateacross = state || '';
    else el.dataset.statedown = state || '';
    applyMergedState(el);
  }

  function validateWordAt(r, c, d){
    const cells = wordCellsAt(r, c, d);
    const guessArr = cells.map(({r,c}) => (grid[r][c].letter || '').toUpperCase());
    const wantArr  = cells.map(({r,c}) => (SOLUTION[r][c] || '').toUpperCase());

    const complete = guessArr.every(ch => ch);
    if (!complete){
      cells.forEach(({r,c}) => setWordStateForCell(r,c,d,''));
      return;
    }
    const correct = guessArr.join('') === wantArr.join('');
    const state = correct ? 'ok' : 'bad';
    cells.forEach(({r,c}) => setWordStateForCell(r,c,d,state));
  }

  function validateBothDirectionsAt(r,c){
    if (LAYOUT[r][c] === null) return;
    validateWordAt(r,c,'across');
    validateWordAt(r,c,'down');
  }

  function validateAllWords(){
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        if (LAYOUT[r][c]===null) continue;
        const left = (c===0 || LAYOUT[r][c-1]===null);
        if (left) validateWordAt(r,c,'across');
      }
    }
    for (let c=0;c<COLS;c++){
      for (let r=0;r<ROWS;r++){
        if (LAYOUT[r][c]===null) continue;
        const top = (r===0 || LAYOUT[r-1]?.[c]===null);
        if (top) validateWordAt(r,c,'down');
      }
    }
  }

  function typeKey(k){
    const cell=getCell(focus.r,focus.c); if (!cell || cell.block) return;
    cell.letter = k;
    cellEl(cell.r,cell.c).querySelector('.letter').textContent = k;
    validateBothDirectionsAt(cell.r, cell.c);
    moveNext(); save(); updateProgress();
    finalCheckIfSolved();
  }

  function backspace(){
    const cell=getCell(focus.r,focus.c); if (!cell || cell.block) return;
    if (cell.letter){
      cell.letter='';
      const el = cellEl(cell.r,cell.c);
      el.querySelector('.letter').textContent='';
      el.dataset.stateacross = '';
      el.dataset.statedown = '';
      applyMergedState(el);
      validateBothDirectionsAt(cell.r, cell.c);
      save(); updateProgress(); return;
    }
    movePrev();
  }

  function moveNext(){ const cells=currentWordCells(); const idx=cells.findIndex(c=>c.r===focus.r && c.c===focus.c); const next=cells[idx+1]; if (next) focus={r:next.r,c:next.c}; updateHighlights(); }
  function movePrev(){ const cells=currentWordCells(); const idx=cells.findIndex(c=>c.r===focus.r && c.c===focus.c); const prev=cells[idx-1]; if (prev) focus={r:prev.r,c:prev.c}; updateHighlights(); }
  function toggleDir(){ dir=(dir==='across')?'down':'across'; updateHighlights(); updateActiveClue(); validateBothDirectionsAt(focus.r, focus.c); }

  function clearWord(){
    currentWordCells().forEach(c=>{
      c.letter='';
      const el = cellEl(c.r,c.c);
      el.querySelector('.letter').textContent='';
      el.dataset.stateacross = '';
      el.dataset.statedown = '';
      applyMergedState(el);
    });
    validateBothDirectionsAt(focus.r, focus.c);
    save(); updateProgress();
  }

  // >>> FIX: render clues ONLY from the 5 picked slots per direction
  function renderClues(){
    acrossCluesEl.innerHTML=''; downCluesEl.innerHTML='';
    [...PICKED_ACROSS].sort((a,b)=>a.num-b.num).forEach(s=>{
      const p=document.createElement('div'); p.className='clue'; p.dataset.num=s.num; p.dataset.dir='across';
      p.innerHTML=`<strong>${s.num}.</strong> ${CLUES_ACROSS[s.num].clue} <small>(${s.len})</small>`;
      p.addEventListener('click',()=>{ focus={r:s.r,c:s.c}; dir='across'; updateHighlights(); updateActiveClue(); validateWordAt(s.r,s.c,'across'); });
      acrossCluesEl.appendChild(p);
    });
    [...PICKED_DOWN].sort((a,b)=>a.num-b.num).forEach(s=>{
      const p=document.createElement('div'); p.className='clue'; p.dataset.num=s.num; p.dataset.dir='down';
      p.innerHTML=`<strong>${s.num}.</strong> ${CLUES_DOWN[s.num].clue} <small>(${s.len})</small>`;
      p.addEventListener('click',()=>{ focus={r:s.r,c:s.c}; dir='down'; updateHighlights(); updateActiveClue(); validateWordAt(s.r,s.c,'down'); });
      downCluesEl.appendChild(p);
    });
  }

  function updateActiveClue(){
    const cell=getCell(focus.r,focus.c);
    if (!cell || cell.block){ activeClueEl.textContent='Tap any cell to begin.'; return; }
    const num = startNumForCurrentWord(focus.r,focus.c,dir);
    const obj = (dir==='across'?CLUES_ACROSS[num]:CLUES_DOWN[num]);
    const text = obj?obj.clue:''; const len = currentWordCells().length;
    activeClueEl.innerHTML = `<strong>${num||'â€“'}.</strong> ${text||''} <small>(${len})</small>`;
    document.querySelectorAll('.clue').forEach(el=>el.classList.remove('active'));
    const el = document.querySelector(`.clue[data-dir="${dir}"][data-num="${num}"]`);
    if (el) el.classList.add('active');
  }

  function startNumForCurrentWord(r,c,d){
    if (d==='across'){ let cc=c; while (cc>0 && !getCell(r,cc-1).block) cc--; return getCell(r,cc).num; }
    let rr=r; while (rr>0 && !getCell(rr-1,c).block) rr--; return getCell(rr,c).num;
  }

  function save(){ const letters=grid.map(row=>row.map(c=>c.letter)); saveProgress({letters,focus,dir}); }
  function load(){
    const p = loadProgress(); if(!p) return;
    try{
      p.letters?.forEach((row,r)=>row.forEach((ch,c)=>{ if (!getCell(r,c).block){ grid[r][c].letter=ch||''; } }));
      focus=p.focus||focus; dir=p.dir||dir;
    }catch{}
  }

  function resetPuzzleKeepWords(){
    grid.flat().forEach(c=>{
      if(!c.block){
        c.letter = '';
        const el = cellEl(c.r,c.c);
        if(el){
          el.querySelector('.letter').textContent='';
          el.dataset.stateacross = '';
          el.dataset.statedown = '';
          el.classList.remove('ok','bad','active','focus');
        }
      }
    });
    clearProgress();
    const first=grid.flat().find(c=>!c.block);
    if (first) focus={r:first.r,c:first.c};
    dir='across';
    updateHighlights(); updateActiveClue(); updateProgress();
    toast('Board cleared. Same words kept.');
  }

  function filledCount(){ let n=0; for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) if (LAYOUT[r][c]!==null && grid[r][c].letter?.trim()) n++; return n; }
  function totalPlayable(){ let n=0; for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) if (LAYOUT[r][c]!==null) n++; return n; }
  function updateProgress(){ progressFill.style.width = Math.round((filledCount()/totalPlayable())*100)+'%'; }

  function finalCheckIfSolved(){
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        if (LAYOUT[r][c]===null) continue;
        const startsAcross = (c===0 || LAYOUT[r][c-1]===null);
        if (startsAcross){
          const cells = wordCellsAt(r,c,'across');
          const guess = cells.map(({r,c}) => (grid[r][c].letter || '').toUpperCase());
          const want  = cells.map(({r,c}) => (SOLUTION[r][c]   || '').toUpperCase());
          if (guess.some(ch => !ch) || guess.join('') !== want.join('')) return;
        }
      }
    }
    for (let c=0;c<COLS;c++){
      for (let r=0;r<ROWS;r++){
        if (LAYOUT[r][c]===null) continue;
        const startsDown = (r===0 || LAYOUT[r-1]?.[c]===null);
        if (startsDown){
          const cells = wordCellsAt(r,c,'down');
          const guess = cells.map(({r,c}) => (grid[r][c].letter || '').toUpperCase());
          const want  = cells.map(({r,c}) => (SOLUTION[r][c]   || '').toUpperCase());
          if (guess.some(ch => !ch) || guess.join('') !== want.join('')) return;
        }
      }
    }
    confetti(); toast('âœ… Correct! Puzzle solved.');
    setTimeout(() => {
      clearProgress();
      const newPuzzle = buildRandomPuzzle();
      savePuzzle(newPuzzle);
      ({ LAYOUT, SOLUTION, CLUES_ACROSS, CLUES_DOWN, pickedAcross: PICKED_ACROSS, pickedDown: PICKED_DOWN } = newPuzzle);
      buildGrid();
      const first=LAYOUT.flat().findIndex(v=>v!==null);
      const fr = Math.floor(first/COLS), fc = first%COLS;
      if (first>=0) focus={r:fr,c:fc};
      renderBoard();
    }, 900);
  }

  function toast(msg){ const t=document.createElement('div'); t.className='toast'; t.textContent=msg; document.body.appendChild(t); setTimeout(()=>t.remove(),1700); }
  function confetti(){
    const container=document.createElement('div'); container.style.position='fixed'; container.style.left='50%'; container.style.top='40%'; container.style.transform='translate(-50%,-50%)'; container.style.pointerEvents='none'; document.body.appendChild(container);
    const emojis=['ðŸŽ‰','âœ¨','ðŸŽŠ','ðŸŒŸ','ðŸŸ¦','ðŸŸ¨'];
    for(let i=0;i<22;i++){ const s=document.createElement('span'); s.textContent=emojis[i%emojis.length]; s.style.position='absolute'; s.style.fontSize=(24+Math.random()*18)+'px'; s.style.left='0px'; s.style.top='0px'; container.appendChild(s); const x=(Math.random()*2-1)*240; const y=-(Math.random()*200+120); s.animate([{transform:'translate(0,0)'},{transform:`translate(${x}px, ${y}px)`,opacity:.1}],{duration:900+Math.random()*500,easing:'cubic-bezier(.2,.6,.2,1)'}).onfinish=()=>s.remove(); }
    setTimeout(()=>container.remove(),1200);
  }

  function computeLayout(){
    const styles = getComputedStyle(document.documentElement);
    const gutter = parseInt(styles.getPropertyValue('--gutter')) || 0;

    const vw = Math.max(0, window.innerWidth  - gutter * 2);
    const vh = Math.max(0, window.innerHeight - gutter * 2);

    const topbarH   = document.querySelector('.topbar')?.offsetHeight || 0;
    const progressH = 6 + 10;
    const hintH     = 22;

    const drawerVisible = !drawer.classList.contains('collapsed');
    let drawerW = 0;
    if (drawerVisible) { drawerW = Math.min(360, Math.floor(vw * 0.35)) + 12; }
    document.documentElement.style.setProperty('--drawerW', drawerW + 'px');

    const portrait = vh >= vw;
    const kbFrac = portrait ? 0.36 : 0.28;
    const kbH = Math.max(120, Math.min(340, (vh - topbarH) * kbFrac));
    const kbRow = (kbH / 4) - 6;

    const sidePad = 12;
    const availW = vw - drawerW - sidePad * 2;
    const availH = vh - topbarH - progressH - kbH - hintH - 60;

    const size = Math.max(300, Math.min(availW, availH));
    document.documentElement.style.setProperty('--board-size', size + 'px');
    document.documentElement.style.setProperty('--kb-row', Math.max(40, kbRow) + 'px');

    board.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
  }

  window.computeLayout = computeLayout;
  window.addEventListener('resize', computeLayout);
  window.addEventListener('orientationchange', computeLayout);

  buildGrid();
  const first = LAYOUT.flat().findIndex(v=>v!==null);
  const fr = Math.floor(first/COLS), fc = first%COLS;
  if (first>=0) focus={r:fr,c:fc};
  renderBoard();
  load();
  updateHighlights(); updateActiveClue(); updateProgress();
  queueMicrotask(()=>{ app.focus(); computeLayout(); validateBothDirectionsAt(focus.r, focus.c); });
})();
</script>
</body>
</html>
