<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Crossword â€“ NSTW 2025 (Touch TV + iPhone)</title>
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#3446b8">
<style>
  :root{
    --vh: 1vh;
    --gap: 2px;
    --cell-min: 50px;
    --focus-outline: 4px;
    --board-size: 720px;
    /* Thicker keyboard by default */
    --kb-row: 72px;
    --gutter: 12px;
    --drawerW: 0px;
    --ink: #0f172a;
    --accent: #5b8cff;
    --ok: #22c55e;
    --bad: #ef4444;
    --ink-soft: #b9c2d0;
  }
  html, body { height: 100%; overflow: hidden; }
  * { box-sizing: border-box; }
  body{
    margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; color:#f8fafc;
    -webkit-tap-highlight-color: transparent;
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    padding-top: calc(env(safe-area-inset-top) * 1);
    padding-bottom: calc(env(safe-area-inset-bottom) * 1);
    background:
      radial-gradient(1100px 700px at 80% 20%, rgba(0,0,0,.25), transparent 60%),
      linear-gradient(rgba(0,0,0,0.20), rgba(0,0,0,0.20)),
      url("assets/Background-33.jpg");
    background-size: cover; background-position: center; background-repeat: no-repeat; background-attachment: fixed;
  }
  .app{ position:relative; height:calc(var(--vh) * 100); max-width:100vw; margin:0 auto; padding:var(--gutter); user-select:none; outline:none; display:flex; flex-direction:column; gap:8px; }
  .topbar{ display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap; }
  .brand{ display:flex; align-items:center; gap:8px; flex:1 1 auto; min-width:0; }
  .brand h1{ margin:0; font-weight:900; letter-spacing:.2px; font-size:clamp(18px,2.6vw,32px); }
  .brand small{ opacity:.85; font-weight:600; color:#b9c2d0; white-space:nowrap; }
  .buttons{ display:flex; gap:6px; overflow:auto; padding-bottom:2px; }
  .buttons::-webkit-scrollbar{ display:none; }
  .btn{
    font:inherit; padding:6px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.28);
    background:rgba(255,255,255,.14); color:#fff; cursor:pointer; touch-action:manipulation;
    backdrop-filter: blur(8px) saturate(120%); -webkit-backdrop-filter: blur(8px) saturate(120%);
    box-shadow: 0 6px 18px rgba(0,0,0,.22), inset 0 0 0 1px rgba(255,255,255,.08);
    transition: transform .08s ease, background .15s ease; white-space:nowrap;
  }
  .btn:active{ transform: translateY(1px) scale(.99); }
  .btn.primary{ background: rgba(255,255,255,.20); border-color: rgba(255,255,255,.36); }
  .btn.badge{ position:relative; padding-left:9px; padding-right:9px; }
  .btn .badge-dot{ width:7px; height:7px; border-radius:50%; background:#22d3ee; display:inline-block; margin-left:6px; }
  .progress{ height:6px; width:100%; background:rgba(255,255,255,.18); border-radius:999px; overflow:hidden; }
  .progress > i{ display:block; height:100%; width:0%; background:linear-gradient(90deg,#22d3ee,#38bdf8,#60a5fa); transition:width .25s ease; }

  .stage{ display:grid; place-items:center; gap:10px; padding-right:var(--drawerW); transition: padding-right .18s ease; }
  .board-wrap{ display:flex; flex-direction:column; align-items:center; gap:10px; }

  /* Board fills width, stays square */
  .board{
    width: clamp(320px, calc(100vw - 2*var(--gutter) - var(--drawerW)), 860px);
    max-width: unset;
    aspect-ratio: 1 / 1;
    height: auto;
    background:rgba(255,255,255,.06);
    display:grid; gap:var(--gap);
    touch-action:manipulation;
    border-radius:16px;
    box-shadow: inset 0 2px 10px rgba(0,0,0,.25), 0 10px 24px rgba(0,0,0,.35);
    padding:6px;
  }
  .board, .clue-ribbon, .kb-wrap{
    width: clamp(320px, calc(100vw - 2*var(--gutter) - var(--drawerW)), 860px);
    margin-left:auto; margin-right:auto;
  }
  .grid{ width:100%; height:100%; display:grid; }

  /* Bigger, multi-line clue ribbon */
  .clue-ribbon{
    display:grid; grid-template-columns:auto 1fr auto auto; gap:10px; align-items:center;
    margin:6px auto 8px; padding:10px; border-radius:14px;
    background:rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.20);
    backdrop-filter: blur(8px) saturate(120%); -webkit-backdrop-filter: blur(8px) saturate(120%);
    box-shadow: 0 8px 20px rgba(0,0,0,.22), inset 0 0 0 1px rgba(255,255,255,.06);
  }
  .clue-ribbon .pill{
    min-height: 48px;
    padding:12px 14px;
    border-radius:12px; font-weight:800; color:#e8eef9;
    background:#0f172a; border:1px dashed rgba(255,255,255,.22);
    font-size: clamp(14px, 2.2vw, 18px);
    line-height:1.3;
    white-space:normal;           /* allow wrapping */
    overflow-wrap:anywhere;       /* long text breaks nicely */
    text-align:left;
  }
  .pill-btn, .pill-secondary{
    font:inherit; font-weight:900; padding:8px 12px; border-radius:12px; cursor:pointer;
    border:1px solid rgba(255,255,255,.28); color:#fff; background:rgba(255,255,255,.12);
    box-shadow: 0 6px 18px rgba(0,0,0,.22), inset 0 0 0 1px rgba(255,255,255,.08);
  }

  .kb-wrap{ padding-bottom:4px; }
  .keyboard{ display:grid; gap:8px; }
  .kb-row{ display:grid; grid-auto-rows: var(--kb-row); gap:8px; }
  .kb-row.row1   { grid-template-columns: repeat(10, 1fr); }
  .kb-row.row2   { grid-template-columns: repeat(9, 1fr); }
  .kb-row.row3   { grid-template-columns: repeat(7, 1fr); }
  .kb-row.actions{ grid-template-columns: 1.4fr 2.2fr 1.6fr; }

  /* CHUNKIER keys */
  .keyboard button{
    border:2px solid rgba(255,255,255,.28);
    border-radius:14px;
    background:linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.12));
    color:#fff;
    font-size:clamp(17px,2.2vw,26px);
    font-weight:800; letter-spacing:.6px;
    box-shadow:
      0 10px 22px rgba(0,0,0,.28),
      inset 0 0 0 1px rgba(255,255,255,.08),
      inset 0 -4px 10px rgba(0,0,0,.18);  /* depth */
    backdrop-filter: blur(8px) saturate(130%); -webkit-backdrop-filter: blur(8px) saturate(130%);
    transition: transform .08s ease, background .12s ease;
  }
  .keyboard button:active{ transform: translateY(1px) scale(.99); }

  .hint{ text-align:center; font-size:12px; color:#e2e8f0; opacity:.95; text-shadow:0 2px 10px rgba(0,0,0,.55); }

  .cell{
    position:relative; background:rgba(255,255,255,.96); display:grid; place-items:center; font-weight:900;
    min-width:var(--cell-min); min-height:var(--cell-min); font-size:clamp(18px,3.6vw,34px);
    border-radius:10px; box-shadow:0 1px 0 rgba(0,0,0,.08); color:#0b1220;
  }
  .cell.block{ background:#0b1120; border-radius:12px; box-shadow: inset 0 0 0 1px rgba(255,255,255,.06); }
  .cell.active:not(.block){ background:linear-gradient(#ffffff,#f8fbff); box-shadow:0 0 0 3px rgba(91,140,255,.18) inset; }
  .cell.focus:not(.block){ outline:var(--focus-outline) solid var(--accent); outline-offset:-4px; z-index:2; }
  .cell.ok{ box-shadow: inset 0 0 0 4px var(--ok); }
  .cell.bad{ box-shadow: inset 0 0 0 4px var(--bad); }
  .num{ position:absolute; top:4px; left:6px; opacity:.85; font-weight:800; font-size:clamp(10px,3vw,14px); line-height:1; color:#64748b; }
  .letter{ letter-spacing:.5px; }

  .clues-drawer{
    position:absolute; right:var(--gutter); top:calc(58px + var(--gutter)); bottom:var(--gutter);
    width:340px; background:#0b1220; border:1px solid #1f2937; border-radius:18px; padding:12px; overflow:hidden;
    box-shadow: 0 14px 34px rgba(0,0,0,.45); transition: transform .18s ease, opacity .18s ease; z-index:30;
  }
  .clues-drawer.collapsed{ transform:translateX(360px); opacity:0; pointer-events:none; }
  .clues-head{ display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
  .clues-head h2{ margin:0; font-size:18px; }
  .clues-body{ position:absolute; inset:56px 10px 10px 10px; overflow:auto; }
  .clue{ font-size:16px; margin:4px 0; padding:8px 10px; border-radius:10px; line-height:1.35; background:#0f172a; border:1px solid transparent; color:#e5eaf3; }
  .clue small{ opacity:.75; }
  .clue.active{ background:#111b2e; border-color:#3756a8; }
  .toast{ position:fixed; left:50%; bottom:calc(16px + env(safe-area-inset-bottom)); transform:translateX(-50%); background:#0b1220; color:#fff; padding:12px 18px; border-radius:12px; font-weight:700; box-shadow:0 14px 30px rgba(0,0,0,.45); }

  /* Ultra-compact for very tall portrait */
  @media (max-width: 760px) and (min-height: 1100px) {
    .brand small{ display:none; }
    :root{ --gap: 2px; }
    .board, .kb-wrap, .clue-ribbon{ width:min(98vw, var(--board-size)); }
  }

  @media (max-width:430px){ :root{--cell-min:40px} .btn{padding:7px 10px} .kb-row{grid-auto-rows:minmax(50px,var(--kb-row))} .clues-drawer{width:320px} }
  @media (max-width:414px){ :root{--cell-min:38px} .brand h1{font-size:20px} .kb-row{grid-auto-rows:minmax(48px,var(--kb-row))} .clues-drawer{width:300px} }
  @media (max-width:390px){ :root{--cell-min:36px} .btn{padding:6px 9px} .keyboard button{font-size:16px} .kb-row{grid-auto-rows:minmax(46px,var(--kb-row))} }
  @media (max-height:500px) and (orientation:landscape){ :root{--kb-row:54px} .keyboard button{font-size:15px} .brand small{display:none} }
</style>
</head>
<body>
<div class="app" tabindex="0" id="app">
  <div class="topbar">
    <div class="brand">
      <h1>Crossword</h1>
      <small>NSTW 2025 â€¢ Touch TV</small>
    </div>
    <div class="buttons">
      <a href="index.html"><button class="btn" id="btnReturn">Return</button></a>
      <button class="btn badge" id="btnClues">Clues <span class="badge-dot"></span></button>
      <button class="btn" id="btnToggle">Across</button>
      <button class="btn" id="btnClear">Clear</button>
      <button class="btn" id="btnReset">Reset</button>
      <button class="btn primary" id="btnFS">Fullscreen</button>
    </div>
  </div>

  <div class="progress"><i id="progressFill"></i></div>

  <div class="stage">
    <div class="board-wrap">
      <div class="board"><div class="grid" id="board" aria-label="Crossword board"></div></div>

      <!-- Bigger clue ribbon -->
      <div class="clue-ribbon" id="clueRibbon" aria-live="polite">
        <button class="pill-btn" id="cluePrev" title="Previous clue">â€¹</button>
        <div class="pill" id="clueText">Tap a cell to begin.</div>
        <button class="pill-btn" id="clueNext" title="Next clue">â€º</button>
        <button class="pill-secondary" id="clueOpen" title="Open all clues">Open</button>
      </div>

      <div class="kb-wrap">
        <div class="keyboard" id="keyboard">
          <div class="kb-row row1"    id="kbRow1"></div>
          <div class="kb-row row2"    id="kbRow2"></div>
          <div class="kb-row row3"    id="kbRow3"></div>
          <div class="kb-row actions" id="kbActions"></div>
        </div>
      </div>
      <div class="hint">Tip: Tap a cell to select; tap again to toggle Across/Down. Arrow keys & D-pads work too.</div>
    </div>
  </div>

  <!-- Drawer -->
  <aside id="drawer" class="clues-drawer collapsed">
    <div class="clues-head">
      <h2 id="setTitle">Active clue</h2>
      <button class="btn" id="btnCloseDrawer" style="padding:6px 10px;">Hide</button>
    </div>
    <div class="clues-body">
      <div id="activeClue" class="clue" style="font-weight:800;border:1px dashed rgba(255,255,255,.18);"></div>
      <h3 style="margin:12px 6px 6px;">Across</h3>
      <div id="acrossClues"></div>
      <h3 style="margin:12px 6px 6px;">Down</h3>
      <div id="downClues"></div>
    </div>
  </aside>
</div>

<script>
(() => {
  if ('serviceWorker' in navigator) { navigator.serviceWorker.register('serviceworker.js'); }

  const RETURN_URL = 'index.html';

  function setVh(){
    const base = window.innerHeight;
    document.documentElement.style.setProperty('--vh', `${base*0.01}px`);
  }
  setVh(); addEventListener('resize',setVh); addEventListener('orientationchange',setVh);

  /* ------------ STRICT grid builder ------------ */
  function makeGridSet(rows, cols, placements){
    const L = Array.from({length:rows},()=>Array(cols).fill(null));
    const S = Array.from({length:rows},()=>Array(cols).fill(null));
    for (const p of placements){
      const {answer, r, c, dir} = p;
      for (let i=0;i<answer.length;i++){
        const rr = r + (dir==='down'?i:0);
        const cc = c + (dir==='across'?i:0);
        L[rr][cc]   = "";
        S[rr][cc]   = answer[i].toUpperCase();
      }
    }
    const startNum = new Map();
    placements.forEach(p => { if (p.num != null) startNum.set(`${p.r},${p.c}`, p.num); });
    const NUMBERS_GRID = Array.from({length:rows},()=>Array(cols).fill(''));
    for (const [key, num] of startNum.entries()){
      const [r,c] = key.split(',').map(Number);
      NUMBERS_GRID[r][c] = num;
    }
    const CLUES_ACROSS = {}, CLUES_DOWN = {};
    for (const p of placements){
      if (p.dir==='across') CLUES_ACROSS[p.num] = { clue: p.clue || '(Across)', answer: p.answer };
      else                  CLUES_DOWN[p.num]   = { clue: p.clue || '(Down)',   answer: p.answer };
    }
    return { LAYOUT:L, SOLUTION:S, CLUES_ACROSS, CLUES_DOWN, NUMBERS_GRID };
  }

  function buildGrid(){
    const LAYOUT = window.LAYOUT, NUMBERS_GRID = window.NUMBERS_GRID;
    grid = LAYOUT.map((row,r)=>row.map((v,c)=>{
      const block = v===null;
      const num = block ? '' : (NUMBERS_GRID?.[r]?.[c] || '');
      return { r,c,block,letter:'',num };
    }));
  }

  /* ------------ Sets ------------ */
  const SETS = [
    { name:'Set 1', placements:[
      { num:1,  answer:'WORK',    r:1,  c:1,  dir:'down',   clue:'What scientists do every day' },
      { num:2,  answer:'PROJECT', r:3,  c:0,  dir:'across', clue:'Basic unit in the investigation of specific S&T problem/s with predetermined objective/s within a time frame' },
      { num:3,  answer:'CANADA',  r:3,  c:5,  dir:'down',   clue:'PhD and MS scholars at University of Alberta' },
      { num:4,  answer:'HEALTH',  r:4,  c:11, dir:'down',   clue:'Field of study in collaboration with Italy' },
      { num:8,  answer:'LAB',     r:7,  c:11, dir:'across', clue:'A place where scientists do experiments' },
      { num:5,  answer:'FUNDING', r:7,  c:2,  dir:'across', clue:'Money provided by an org/government for a purpose' },
      { num:6,  answer:'UK',      r:7,  c:3,  dir:'down',   clue:'Top partnership is on health, environment, and agriculture' },
      { num:7,  answer:'GRANT',   r:7,  c:8,  dir:'down',   clue:'Financial assistance provided for a specific purpose' },
      { num:9,  answer:'EARTH',   r:9,  c:7,  dir:'across', clue:'The planet where we live' },
      { num:10, answer:'TECH',    r:11, c:8,  dir:'across', clue:'Short for â€œtechnologyâ€' },
    ]},
    { name:'Set 2', placements:[
      { num:1, answer:'TEAM',    r:2,  c:9,  dir:'down',   clue:'A group of people working together' },
      { num:2, answer:'TAIWAN',  r:3,  c:11, dir:'down',   clue:'Joint researches and sandwich scholarship programs' },
      { num:3, answer:'JAPAN',   r:4,  c:8,  dir:'across', clue:'Osaka and Nagoya' },
      { num:4, answer:'FRANCE',  r:6,  c:7,  dir:'down',   clue:'Sending PhD scholars at Texas Tech University taking up Plant and Soil Science' },
      { num:5, answer:'BASIC',   r:7,  c:3,  dir:'down',   clue:'Type of research that focuses on expanding general knowledge and theory' },
      { num:6, answer:'PROGRAM', r:7,  c:6,  dir:'across', clue:'Group of interrelated/complementing S&T projects meeting a goal within a time frame' },
      { num:7, answer:'USA',     r:8,  c:1,  dir:'across', clue:'PhD scholars at Texas Tech University taking up Plant and Soil Science' },
      { num:8, answer:'SCIENCE', r:9,  c:3,  dir:'across', clue:'The study of nature and how things work' },
      { num:9, answer:'HELP',    r:11, c:6,  dir:'across', clue:'What scientists do for the people' },
    ]},
    { name:'Set 3', placements:[
      { num:1,  answer:'IDEA',    r:0,  c:6,  dir:'down',   clue:'The beginning of every new invention' },
      { num:2,  answer:'CLM',     r:1,  c:2,  dir:'down',   clue:'One of the most notable partnership output is the technical cooperation ASEAN scholarship' },
      { num:3,  answer:'LEADER',  r:2,  c:2,  dir:'across', clue:'The person who plans, organizes and supervises the overall activities of a program or project' },
      { num:4,  answer:'APPLIED', r:2,  c:4,  dir:'down',   clue:'Type of research that aims to solve specific, real-world problems by using existing knowledge' },
      { num:5,  answer:'COUNTRY', r:3,  c:9,  dir:'down',   clue:'An area of land, which has its own government and laws' },
      { num:6,  answer:'PEOPLE',  r:6,  c:6,  dir:'down',   clue:'Individual human beings; Collective or community of an ethnic group or nation' },
      { num:7,  answer:'BENEFIT', r:7,  c:3,  dir:'across', clue:'Something that produces good and helpful results or effects or that promotes well-being' },
      { num:8,  answer:'DATA',    r:10, c:10, dir:'down',   clue:'Information collected from experiments' },
      { num:9,  answer:'EASIA',   r:11, c:6,  dir:'across', clue:'Top partnership is on health and climate & weather' },
      { num:10, answer:'INDIA',   r:13, c:6,  dir:'across', clue:'The partnership is on AI, engineering, and health.' },
    ]}
  ];

  /* ------------ engine state ------------ */
  const STORAGE_KEY = 'crossword-nstw2025-v7-14x14';
  const CURRENT_SET_KEY = `${STORAGE_KEY}::currentSet`;
  const ROWS = 14, COLS = 14;
  let grid = [];
  let focus = { r:0, c:0 };
  let dir = 'across';
  let currentSetIndex = 0;

  const app = document.getElementById('app');
  const board = document.getElementById('board');
  const progressFill = document.getElementById('progressFill');
  const activeClueEl = document.getElementById('activeClue');
  const acrossCluesEl = document.getElementById('acrossClues');
  const downCluesEl = document.getElementById('downClues');
  const drawer = document.getElementById('drawer');
  const setTitle = document.getElementById('setTitle');

  // Ribbon refs
  const clueTextEl = document.getElementById('clueText');
  const cluePrev   = document.getElementById('cluePrev');
  const clueNext   = document.getElementById('clueNext');
  const clueOpen   = document.getElementById('clueOpen');

  // Keyboard refs
  const kbRow1    = document.getElementById('kbRow1');
  const kbRow2    = document.getElementById('kbRow2');
  const kbRow3    = document.getElementById('kbRow3');
  const kbActions = document.getElementById('kbActions');

  function makeKey(label, handler){
    const b = document.createElement('button');
    b.textContent = label;
    b.addEventListener('pointerdown', e => { e.preventDefault(); handler(); if (navigator.vibrate) navigator.vibrate(8); }, { passive: false });
    return b;
  }

  "QWERTYUIOP".split('').forEach(k => kbRow1.appendChild(makeKey(k, () => typeKey(k))));
  "ASDFGHJKL".split('').forEach(k => kbRow2.appendChild(makeKey(k, () => typeKey(k))));
  "ZXCVBNM".split('').forEach(k => kbRow3.appendChild(makeKey(k, () => typeKey(k))));
  kbActions.appendChild(makeKey('âŒ«', backspace));
  kbActions.appendChild(makeKey('ACROSS/DOWN', toggleDir));
  kbActions.appendChild(makeKey('CLEAR', clearWord));

  document.getElementById('btnReturn').addEventListener('click', returnToLanding);
  document.getElementById('btnToggle').addEventListener('click', () => { toggleDir(); app.focus(); });
  document.getElementById('btnClear').addEventListener('click', clearWord);
  document.getElementById('btnReset').addEventListener('click', resetPuzzle);
  document.getElementById('btnFS').addEventListener('click', () => { document.documentElement.requestFullscreen?.(); });
  document.getElementById('btnClues').addEventListener('click', () => { drawer.classList.toggle('collapsed'); computeLayout(); });
  document.getElementById('btnCloseDrawer').addEventListener('click', () => { drawer.classList.add('collapsed'); computeLayout(); });

  cluePrev.addEventListener('click', ()=> jumpClue(-1));
  clueNext.addEventListener('click', ()=> jumpClue(+1));
  clueOpen .addEventListener('click', ()=> { drawer.classList.remove('collapsed'); computeLayout(); });

  function returnToLanding(){
    try{
      const ref = document.referrer || '';
      const sameOrigin = ref && new URL(ref).origin === location.origin;
      if (sameOrigin && history.length > 1) { history.back(); return; }
    }catch{}
    location.href = RETURN_URL;
  }

  const onKey = (e) => {
    const tag=(e.target.tagName||'').toLowerCase(); if (['input','textarea','select'].includes(tag) || e.isComposing) return;
    const k=e.key.toUpperCase(); if (e.repeat){ e.preventDefault(); return; }
    if (/^[A-Z]$/.test(k)) { e.preventDefault(); e.stopPropagation(); typeKey(k); return; }
    if (e.key==='Backspace') { e.preventDefault(); e.stopPropagation(); backspace(); return; }
    if (e.key==='ArrowRight'){ e.preventDefault(); dir='across'; moveNext(); return; }
    if (e.key==='ArrowLeft') { e.preventDefault(); dir='across'; movePrev(); return; }
    if (e.key==='ArrowDown') { e.preventDefault(); dir='down';   moveNext(); return; }
    if (e.key==='ArrowUp')   { e.preventDefault(); dir='down';   movePrev(); return; }
  };
  if (!window.__CROSSWORD_KEYS_BOUND__){ addEventListener('keydown', onKey, {capture:true}); window.__CROSSWORD_KEYS_BOUND__=true; }
  addEventListener('pointerdown', (ev)=>{ const tag=(ev.target.tagName||'').toLowerCase(); if (!['input','textarea','select'].includes(tag)) app?.focus?.(); }, {passive:true});

  /* ------------ load a set ------------ */
  function loadSet(index){
    currentSetIndex = index;
    localStorage.setItem(CURRENT_SET_KEY, String(index));

    const conf = SETS[index];
    const { LAYOUT, SOLUTION, CLUES_ACROSS, CLUES_DOWN, NUMBERS_GRID } =
      makeGridSet(ROWS, COLS, conf.placements);

    window.LAYOUT        = LAYOUT;
    window.SOLUTION      = SOLUTION;
    window.CLUES_ACROSS  = CLUES_ACROSS;
    window.CLUES_DOWN    = CLUES_DOWN;
    window.NUMBERS_GRID  = NUMBERS_GRID;

    setTitle.textContent = `${conf.name} â€“ Active clue`;

    buildGrid();
    loadLetters();
    renderBoard();

    const first=grid.flat().find(c=>!c.block); if (first) focus={r:first.r,c:first.c};
    updateHighlights(); updateActiveClue(); updateProgress(); computeLayout();
  }

  function renderBoard(){
    board.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
    board.style.gridTemplateRows    = `repeat(${ROWS}, 1fr)`;
    board.innerHTML = '';

    grid.flat().forEach(cell => {
      const el = document.createElement('div');
      el.className = `cell${cell.block ? ' block' : ''}`;
      el.dataset.r = cell.r;
      el.dataset.c = cell.c;
      el.dataset.stateacross = '';
      el.dataset.statedown   = '';
      if (cell.num){
        const s = document.createElement('small');
        s.className = 'num';
        s.textContent = cell.num;
        el.appendChild(s);
      }
      const span = document.createElement('span');
      span.className = 'letter';
      span.textContent = cell.letter || '';
      el.appendChild(span);

      el.addEventListener('pointerdown', e => { e.preventDefault(); onCellTap(cell); }, {passive:false});
      board.appendChild(el);
    });

    updateHighlights();
    renderClues();
    updateActiveClue();
    validateAllWords();
    computeLayout();
    updateProgress();
  }

  function getCell(r,c){ return grid[r]?.[c]; }
  function cellEl(r,c){ return board.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); }

  function onCellTap(cell){
    if (cell.block) return;
    const same = (cell.r===focus.r && cell.c===focus.c);
    if (same) dir=(dir==='across')?'down':'across';
    focus={r:cell.r,c:cell.c};
    if (wordCellsAt(focus.r,focus.c,dir).length===1){ dir=(dir==='across')?'down':'across'; }
    updateHighlights(); updateActiveClue(); validateBothDirectionsAt(focus.r, focus.c); saveLetters();
  }

  function wordCellsAt(r,c,d){
    const cells=[];
    if (d==='across'){
      let cc=c; while (cc>0 && !getCell(r,cc-1).block) cc--;
      while (cc<COLS && !getCell(r,cc).block){ cells.push(getCell(r,cc)); cc++; }
    } else {
      let rr=r; while (rr>0 && !getCell(rr-1,c).block) rr--;
      while (rr<ROWS && !getCell(rr,c).block){ cells.push(getCell(rr,c)); rr++; }
    }
    return cells;
  }
  function currentWordCells(){ return wordCellsAt(focus.r,focus.c,dir); }

  function updateHighlights(){
    board.querySelectorAll('.cell').forEach(el=>el.classList.remove('active','focus'));
    currentWordCells().forEach(c=>{ const el=cellEl(c.r,c.c); if (el) el.classList.add('active'); });
    const f=cellEl(focus.r,focus.c); if (f && !getCell(focus.r,focus.c).block) f.classList.add('focus');
    document.getElementById('btnToggle').textContent=(dir==='across')?'Across':'Down';
  }

  function applyMergedState(el){
    const a=el.dataset.stateacross||''; const d=el.dataset.statedown||'';
    el.classList.remove('ok','bad');
    if (a==='bad'||d==='bad') el.classList.add('bad');
    else if (a==='ok'||d==='ok') el.classList.add('ok');
  }
  function setWordStateForCell(r,c,dd,state){
    const el=cellEl(r,c); if (!el) return;
    if (dd==='across') el.dataset.stateacross=state||''; else el.dataset.statedown=state||'';
    applyMergedState(el);
  }

  function validateWordAt(r,c,d){
    const cells=wordCellsAt(r,c,d);
    const guess=cells.map(({r,c})=>(grid[r][c].letter||'').toUpperCase());
    const want =cells.map(({r,c})=>(window.SOLUTION[r][c]||'').toUpperCase());
    if (guess.some(ch=>!ch)){ cells.forEach(({r,c})=>setWordStateForCell(r,c,d,'')); return; }
    const ok = guess.join('')===want.join(''); const st=ok?'ok':'bad'; cells.forEach(({r,c})=>setWordStateForCell(r,c,d,st));
  }
  function validateBothDirectionsAt(r,c){
    if (window.LAYOUT[r][c]===null) return;
    validateWordAt(r,c,'across'); validateWordAt(r,c,'down');
  }
  function validateAllWords(){
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
      if (window.LAYOUT[r][c]===null) continue;
      const start=(c===0||window.LAYOUT[r][c-1]===null);
      if (start) validateWordAt(r,c,'across');
    }
    for (let c=0;c<COLS;c++) for (let r=0;r<ROWS;r++){
      if (window.LAYOUT[r][c]===null) continue;
      const start=(r===0||window.LAYOUT[r-1]?.[c]===null);
      if (start) validateWordAt(r,c,'down');
    }
  }

  function typeKey(k){
    if (!drawer.classList.contains('collapsed')) { drawer.classList.add('collapsed'); computeLayout(); }
    const cell=getCell(focus.r,focus.c); if (!cell || cell.block) return;
    cell.letter=k;
    cellEl(cell.r,cell.c).querySelector('.letter').textContent=k;
    validateBothDirectionsAt(cell.r,cell.c);
    moveNext(); saveLetters(); updateProgress(); finalCheckIfSolved();
  }
  function backspace(){
    const cell=getCell(focus.r,focus.c); if (!cell || cell.block) return;
    if (cell.letter){
      cell.letter='';
      cellEl(cell.r,cell.c).querySelector('.letter').textContent='';
      validateBothDirectionsAt(cell.r,cell.c);
      saveLetters(); updateProgress(); return;
    }
    movePrev();
  }
  function moveNext(){
    const cells=currentWordCells();
    const idx=cells.findIndex(c=>c.r===focus.r && c.c===focus.c);
    const next=cells[idx+1]; if (next) focus={r:next.r,c:next.c};
    updateHighlights();
  }
  function movePrev(){
    const cells=currentWordCells();
    const idx=cells.findIndex(c=>c.r===focus.r && c.c===focus.c);
    const prev=cells[idx-1]; if (prev) focus={r:prev.r,c:prev.c};
    updateHighlights();
  }
  function toggleDir(){ dir=(dir==='across')?'down':'across'; updateHighlights(); updateActiveClue(); validateBothDirectionsAt(focus.r,focus.c); }
  function clearWord(){
    currentWordCells().forEach(c=>{
      c.letter='';
      const el=cellEl(c.r,c.c);
      el.querySelector('.letter').textContent='';
      el.dataset.stateacross=''; el.dataset.statedown='';
      el.classList.remove('ok','bad');
    });
    validateBothDirectionsAt(focus.r,focus.c); saveLetters(); updateProgress();
  }

  function renderClues(){
    acrossCluesEl.innerHTML=''; downCluesEl.innerHTML='';
    const add = (map, dir) => {
      Object.keys(map).sort((a,b)=>a-b).forEach(num=>{
        const target = grid.flat().find(c => c.num == num);
        if (!target) return;
        const len = wordCellsAt(target.r, target.c, dir).length;
        const el=document.createElement('div'); el.className='clue'; el.dataset.num=num; el.dataset.dir=dir;
        el.innerHTML=`<strong>${num}.</strong> ${map[num].clue} <small>(${len})</small>`;
        el.addEventListener('click',()=>{
          focus={r:target.r,c:target.c}; dir=dir;
          updateHighlights(); updateActiveClue(); validateWordAt(target.r,target.c,dir);
          drawer.classList.add('collapsed'); computeLayout(); app.focus?.();
        });
        (dir==='across'?acrossCluesEl:downCluesEl).appendChild(el);
      });
    };
    add(window.CLUES_ACROSS,'across');
    add(window.CLUES_DOWN,'down');
  }

  function startCellFor(r,c,d){
    if (d==='across'){ while (c>0 && !getCell(r,c-1).block) c--; return {r,c}; }
    while (r>0 && !getCell(r-1,c).block) r--; return {r,c};
  }
  function allStarts(dirWant){
    const out=[];
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        if (window.LAYOUT[r][c]===null) continue;
        const startA = (c===0||window.LAYOUT[r][c-1]===null);
        const startD = (r===0||window.LAYOUT[r-1]?.[c]===null);
        if (dirWant==='across' && startA) out.push({r,c,dir:'across', num: grid[r][c].num});
        if (dirWant==='down'   && startD)  out.push({r,c,dir:'down',   num: grid[r][c].num});
      }
    }
    return out.filter(s=>s.num).sort((a,b)=>a.num-b.num);
  }
  function jumpClue(delta){
    const sc = startCellFor(focus.r, focus.c, dir);
    theCurrent = grid[sc.r][sc.c].num || 1;
    const currentNum = theCurrent;
    const list = allStarts(dir);
    const idx  = Math.max(0, list.findIndex(s=>s.num==currentNum));
    const next = list[(idx + delta + list.length) % list.length] || list[0];
    if (!next) return;
    dir = next.dir; focus = { r: next.r, c: next.c };
    updateHighlights(); updateActiveClue(); validateWordAt(next.r,next.c,dir);
    cellEl(next.r,next.c)?.scrollIntoView({block:'nearest', inline:'nearest'});
  }

  function updateActiveClue(){
    const cell=getCell(focus.r,focus.c);
    if (!cell || cell.block){
      activeClueEl.textContent='Tap any cell to begin.';
      clueTextEl.textContent = 'Tap a cell to begin.';
      return;
    }
    const start = (() => {
      if (dir==='across'){ let cc=focus.c; while (cc>0 && !getCell(focus.r,cc-1).block) cc--; return getCell(focus.r,cc); }
      let rr=focus.r; while (rr>0 && !getCell(rr-1,focus.c).block) rr--; return getCell(rr,focus.c);
    })();
    const num = start.num || '';
    const obj=(dir==='across'?window.CLUES_ACROSS[num]:window.CLUES_DOWN[num]);
    const text=obj?obj.clue:''; const len=currentWordCells().length;

    activeClueEl.innerHTML = num ? `<strong>${num}.</strong> ${text} <small>(${len})</small>` : '(Select a numbered start)';
    clueTextEl.textContent = num ? `${num}. ${text} (${len}) â€” ${dir.toUpperCase()}` : '(Select a numbered start)';

    document.querySelectorAll('.clue').forEach(el=>el.classList.remove('active'));
    const el=document.querySelector(`.clue[data-dir="${dir}"][data-num="${num}"]`); if (el) el.classList.add('active');
  }

  function storageKeyForSet(){ return `${STORAGE_KEY}::${currentSetIndex}`; }
  function saveLetters(){
    const letters=grid.map(row=>row.map(c=>c.letter));
    localStorage.setItem(storageKeyForSet(), JSON.stringify({letters,focus,dir}));
  }
  function loadLetters(){
    const raw=localStorage.getItem(storageKeyForSet()); if (!raw) return;
    try{
      const {letters,focus:f,dir:d}=JSON.parse(raw);
      letters?.forEach((row,r)=>row.forEach((ch,c)=>{ if (!getCell(r,c).block){ grid[r][c].letter=ch||''; } }));
      focus=f||focus; dir=d||dir;
    }catch{}
  }
  function resetPuzzle(){ localStorage.removeItem(storageKeyForSet()); loadSet(currentSetIndex); toast('Puzzle reset.'); }

  function filledCount(){ let n=0; for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) if (window.LAYOUT[r][c]!==null && grid[r][c].letter?.trim()) n++; return n; }
  function totalPlayable(){ let n=0; for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) if (window.LAYOUT[r][c]!==null) n++; return n; }
  function updateProgress(){ progressFill.style.width = Math.round((filledCount()/totalPlayable())*100)+'%'; }

  function clearAllLetters(){
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        if (window.LAYOUT[r][c]===null) continue;
        const cell = grid[r][c];
        cell.letter = '';
        const el = cellEl(r,c);
        if (el){
          el.querySelector('.letter').textContent = '';
          el.dataset.stateacross = '';
          el.dataset.statedown   = '';
          el.classList.remove('ok','bad','active','focus');
        }
      }
    }
    localStorage.removeItem(storageKeyForSet());
    updateProgress();
  }


  function confetti({
  bursts = 2,          // 2â€“3 looks great, but 2 is lighter
  perBurst = 120,      // pieces per burst
  duration = 1600,     // ms; each piece animates for this long
  emojiChance = 0.08,  // 8% emojis; set 0 for none
} = {}) {
  // Respect reduced motion
  const rmp = window.matchMedia('(prefers-reduced-motion: reduce)');
  if (rmp.matches) return;

  // Adaptive counts: scale down on huge screens or high DPR
  const dpr = Math.min(1.5, window.devicePixelRatio || 1);
  const area = innerWidth * innerHeight;
  const scale = Math.min(1, (area / (1280*720)) * (1 / dpr));
  const totalPerBurst = Math.max(60, Math.floor(perBurst * scale));

  // Container overlay
  const wrap = document.createElement('div');
  wrap.className = 'confetti-wrap';
  wrap.style.cssText = `
    position:fixed; inset:0; pointer-events:none; z-index:9999; overflow:hidden;
  `;
  document.body.appendChild(wrap);

  const colors = ['#22d3ee','#38bdf8','#60a5fa','#34d399','#fbbf24','#f472b6','#ef4444','#22c55e','#a78bfa','#f59e0b'];
  const emojis = ['ðŸŽ‰','ðŸŽŠ','âœ¨','ðŸŒŸ','ðŸŽˆ','ðŸ’«'];

  const sources = [
    { x: 0.15, angleDeg: -90 },
    { x: 0.50, angleDeg: -90 },
    { x: 0.85, angleDeg: -90 },
  ];

  // Build pieces for each burst using DOM + CSS keyframes
  const burstGap = 140; // ms between bursts
  for (let b = 0; b < bursts; b++) {
    setTimeout(() => {
      const src = sources[b % sources.length];
      for (let i = 0; i < totalPerBurst; i++) {
        const piece = document.createElement('i');
        const isEmoji = Math.random() < emojiChance;

        // Randomize geometry via CSS variables (GPU transforms only)
        const startX = (src.x * innerWidth) + (Math.random()*120 - 60); // slight horizontal spread
        const startY = innerHeight * 0.82 + (Math.random()*40 - 20);
        const driftX = (Math.random() * 340 - 170);   // side sway
        const rise = -(Math.random()*220 + 140);      // upward pop before falling
        const rot = Math.random() * 360;
        const delay = Math.random() * 120;            // small inner-stagger
        const scaleP = isEmoji ? (Math.random()*0.7 + 0.9) : (Math.random()*0.7 + 0.6);

        piece.style.setProperty('--sx', `${startX}px`);
        piece.style.setProperty('--sy', `${startY}px`);
        piece.style.setProperty('--dx', `${driftX}px`);
        piece.style.setProperty('--rise', `${rise}px`);
        piece.style.setProperty('--rot', `${rot}deg`);
        piece.style.setProperty('--scale', scaleP);
        piece.style.setProperty('--t', `${duration}ms`);
        piece.style.setProperty('--delay', `${delay}ms`);

        if (isEmoji) {
          piece.textContent = emojis[(Math.random()*emojis.length)|0];
          piece.className = 'confetti emoji';
        } else {
          piece.className = 'confetti rect';
          const c = colors[(Math.random()*colors.length)|0];
          piece.style.background = `linear-gradient(135deg, ${c}, #fff)`;
        }

        wrap.appendChild(piece);
      }
    }, b * burstGap);
  }

  // Cleanup: remove after longest animation
  const totalTime = bursts * burstGap + duration + 600;
  setTimeout(() => wrap.remove(), totalTime);

  // Inject CSS once
  const SID = 'confetti-css-lite';
  if (!document.getElementById(SID)) {
    const css = document.createElement('style');
    css.id = SID;
    css.textContent = `
      .confetti-wrap .confetti{
        position:absolute;
        left:var(--sx); top:var(--sy);
        transform:translate3d(0,0,0) rotate(var(--rot)) scale(var(--scale));
        will-change: transform, opacity;
        animation: confettiFall var(--t) cubic-bezier(.2,.6,.2,1) var(--delay) forwards,
                   confettiSpin var(--t) linear var(--delay) forwards;
      }
      .confetti-wrap .confetti.rect{
        width:10px; height:14px; border-radius:2px;
        box-shadow:0 0 0 1px rgba(255,255,255,.45) inset;
      }
      .confetti-wrap .confetti.emoji{
        font-size:28px; line-height:1; filter: drop-shadow(0 2px 2px rgba(0,0,0,.25));
        animation: confettiFall var(--t) cubic-bezier(.2,.6,.2,1) var(--delay) forwards,
                   confettiBob var(--t) ease-in-out var(--delay) forwards;
      }
      @keyframes confettiFall{
        0%   { transform: translate3d(0,0,0) rotate(var(--rot)) scale(var(--scale)); opacity:1; }
        45%  { transform: translate3d(calc(var(--dx)*0.5), var(--rise), 0) rotate(calc(var(--rot) + 90deg)) scale(var(--scale)); }
        100% { transform: translate3d(var(--dx), 28vh, 0) rotate(calc(var(--rot) + 240deg)) scale(var(--scale)); opacity:0; }
      }
      @keyframes confettiSpin{
        0% { filter:brightness(1); }
        50%{ filter:brightness(1.15); }
        100%{ filter:brightness(1); }
      }
      @keyframes confettiBob{
        0% { transform: translate3d(0,0,0) rotate(0deg) scale(var(--scale)); }
        100% { transform: translate3d(var(--dx), 28vh, 0) rotate(360deg) scale(var(--scale)); }
      }
    `;
    document.head.appendChild(css);
  }
}


  function finalCheckIfSolved(){
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
      if (window.LAYOUT[r][c]===null) continue;
      const startA=(c===0||window.LAYOUT[r][c-1]===null);
      if (startA){
        const cells=wordCellsAt(r,c,'across');
        const g=cells.map(({r,c})=>(grid[r][c].letter||'').toUpperCase());
        const w=cells.map(({r,c})=>(window.SOLUTION[r][c]||'').toUpperCase());
        if (g.some(ch=>!ch) || g.join('')!==w.join('')) return;
      }
    }
    for (let c=0;c<COLS;c++) for (let r=0;r<ROWS;r++){
      if (window.LAYOUT[r][c]===null) continue;
      const startD=(r===0||window.LAYOUT[r-1]?.[c]===null);
      if (startD){
        const cells=wordCellsAt(r,c,'down');
        const g=cells.map(({r,c})=>(grid[r][c].letter||'').toUpperCase());
        const w=cells.map(({r,c})=>(window.SOLUTION[r][c]||'').toUpperCase());
        if (g.some(ch=>!ch) || g.join('')!==w.join('')) return;
      }
    }

    confetti(); toast('âœ… Correct! Loading another setâ€¦');
    clearAllLetters();

    setTimeout(() => {
      const next = randomOtherIndex(currentSetIndex, SETS.length);
      localStorage.setItem(CURRENT_SET_KEY, String(next));
      loadSet(next);
    }, 900);
  }

  function randomOtherIndex(cur,n){ const opts=[...Array(n).keys()].filter(i=>i!==cur); return opts[Math.floor(Math.random()*opts.length)] || cur; }
  function toast(msg){ const t=document.createElement('div'); t.className='toast'; t.textContent=msg; document.body.appendChild(t); setTimeout(()=>t.remove(),1700); }

  /* ------------ responsive layout ------------ */
  function computeLayout(){
    const styles=getComputedStyle(document.documentElement);
    const gutter=parseInt(styles.getPropertyValue('--gutter'))||0;

    const vw=Math.max(0, innerWidth - gutter*2);
    const vh=Math.max(0, innerHeight - gutter*2);

    const topbarH=document.querySelector('.topbar')?.offsetHeight||0;
    const ribbonH=document.getElementById('clueRibbon')?.offsetHeight||0;
    const progressH=10, hintH=18;

    const drawerVisible=!drawer.classList.contains('collapsed');
    let drawerW=0; if (drawerVisible) drawerW=Math.min(320, Math.floor(vw*0.35)) + 10;
    document.documentElement.style.setProperty('--drawerW', drawerW+'px');

    const portrait = vh >= vw;

    /* Taller keyboard to make keys chunky; still capped so board fits */
    let kbFrac = portrait ? 0.24 : 0.26;
    if (portrait && vh > 1100 && vw <= 760) kbFrac = 0.22;
    const kbH = Math.max(140, Math.min(260, Math.floor((vh-topbarH)*kbFrac)));
    const kbRow = Math.max(50, Math.min(74, Math.floor(kbH/4) - 6));

    const sidePad=10;
    const availW=vw-drawerW-sidePad*2;

    const verticalUsed = topbarH + progressH + ribbonH + kbH + hintH + 28;
    const availH = Math.max(260, vh - verticalUsed);

    const size = Math.max(320, Math.min(availW, availH, 860));
    document.documentElement.style.setProperty('--board-size', size+'px');
    document.documentElement.style.setProperty('--kb-row', kbRow+'px');
  }

  /* ------------ boot ------------ */
  const savedIdxRaw = localStorage.getItem(CURRENT_SET_KEY);
  const savedIdx = Number(savedIdxRaw);
  const startIdx = Number.isInteger(savedIdx) && savedIdx >= 0 && savedIdx < SETS.length
    ? savedIdx
    : Math.floor(Math.random() * SETS.length);

  loadSet(startIdx);

  window.computeLayout = computeLayout;
  addEventListener('resize', computeLayout);
  addEventListener('orientationchange', computeLayout);
  queueMicrotask(()=>{ app.focus(); computeLayout(); });
})();
</script>
</body>
</html>
